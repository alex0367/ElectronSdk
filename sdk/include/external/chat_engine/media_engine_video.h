#ifndef AGORA_MEDIA_ENGINE_BASE_H
#define AGORA_MEDIA_ENGINE_BASE_H

#include "videocommon.h"

namespace agora
{

  template <typename VideoFrameT>
  class VideoSinkInterface {
  public:
    virtual ~VideoSinkInterface() {}

    virtual void OnFrame(const VideoFrameT& frame) = 0;
  };

  // VideoSinkWants is used for notifying the source of properties a video frame
  // should have when it is delivered to a certain sink.
  struct VideoSinkWants {
    VideoSinkWants() {}
    ~VideoSinkWants() {}
    // Tells the source whether the sink wants frames with rotation applied.
    // By default, any rotation must be applied by the sink.
    bool rotation_applied = false;
  };

  template <typename VideoFrameT>
  class VideoSourceInterface {
  public:
    virtual ~VideoSourceInterface() {}

    virtual void AddOrUpdateSink(VideoSinkInterface<VideoFrameT>* sink,
      const VideoSinkWants& wants) = 0;
    // RemoveSink must guarantee that at the time the method returns,
    // there is no current and no future calls to VideoSinkInterface::OnFrame.
    virtual void RemoveSink(VideoSinkInterface<VideoFrameT>* sink) = 0;
  };

  enum CaptureState {
    CS_STOPPED,    // The capturer has been stopped or hasn't started yet.
    CS_STARTING,   // The capturer is in the process of starting. Note, it may
    // still fail to start.
    CS_RUNNING,    // The capturer has been started successfully and is now
    // capturing.
    CS_FAILED,     // The capturer failed to start.
  };

  class VideoCapturerInterface{
  public:
    virtual ~VideoCapturerInterface() {}

    virtual bool Initialize(const char device_id[1024]) = 0;
    virtual bool Dispose() = 0;
    // Start the video capturer with the specified capture format.
    virtual CaptureState Start(const VideoFormat& capture_format) = 0;
    // Stop the video capturer.
    virtual CaptureState Stop() = 0;
    // get frame type generated by capturer
    virtual VIDEO_FRAME_TYPE GetBufferType() = 0;
    // New frame is available, must call sink->OnFrame
    //virtual void OnFrame(const VideoFrame& frame) = 0;
  public:
    VideoSinkInterface<VideoFrame> *sink_;
  };

  enum RenderState {
    RS_STOPPED,    // The renderer has been stopped or hasn't started yet.
    RS_STARTING,   // The renderer is in the process of starting. Note, it may
    // still fail to start.
    RS_RUNNING,    // The renderer has been started successfully and is now
    // capturing.
    RS_FAILED,     // The renderer failed to start.
  };

  class VideoRendererInterface{
  public:
    virtual ~VideoRendererInterface() {}

    virtual bool Initialize(void* view) = 0;
    virtual bool Dispose() = 0;
    // start the renderer
    virtual RenderState Start(const RenderFormat& render_format) = 0;
    // stop the renderer
    virtual RenderState Stop() = 0;
    // get frame type requested by renderer
    virtual VIDEO_FRAME_TYPE GetBufferType() = 0;
    // this function get called when new frame becomes available
    virtual void OnFrame(const VideoFrame& frame) = 0;
  };

  enum FilterState {
    FS_STOPPED,    // The renderer has been stopped or hasn't started yet.
    FS_STARTING,   // The renderer is in the process of starting. Note, it may
    // still fail to start.
    FS_RUNNING,    // The renderer has been started successfully and is now
    // capturing.
    FS_FAILED,     // The renderer failed to start.
  };

  class VideoFilterInterface{
  public:
    virtual ~VideoFilterInterface() {}

    virtual bool Initialize() = 0;
    virtual bool Dispose() = 0;
    // start the filter
    virtual FilterState Start(const VideoFormat& filter_format) = 0;
    // stop the filter
    virtual void Stop() = 0;
    // get frame type requested by filter
    virtual VIDEO_FRAME_TYPE GetBufferType() = 0;
    // this function get called when new frame becomes available
    virtual void OnFrame(const VideoFrame& frame) = 0;
  };

  class AgoraVideoInput;
  class AgoraVideoOutput;
  class AgoraVideoFilter;

  enum VideoTrackType
  {
    TRACK_UNKNOWN = 0,
    TRACK_SEND = 1,
    TRACK_RECEIVE = 2
  };

  class VideoTrack
  {
  public:
    virtual ~VideoTrack() {}
    int track_id;
    VideoTrackType track_type;
  };

  class VideoSendTrack : public VideoTrack
  {
  public:
    virtual ~VideoSendTrack() {}
    virtual bool UpdateCapturer(AgoraVideoInput *capturer) = 0;
    //virtual bool UpdateFilter(AgoraVideoFilter *filter) = 0;
    virtual bool UpdateRenderer(AgoraVideoOutput *renderer) = 0;

    virtual AgoraVideoInput* Capturer() = 0;
    //virtual AgoraVideoFilter* Filter() = 0;
    virtual AgoraVideoOutput* Renderer() = 0;
  };

  class VideoReceiveTrack : public VideoTrack
  {
  public:
    virtual ~VideoReceiveTrack() {}
    virtual bool UpdateRenderer(AgoraVideoOutput *renderer) = 0;

    virtual AgoraVideoOutput* Renderer() = 0;
  };

}

#endif
